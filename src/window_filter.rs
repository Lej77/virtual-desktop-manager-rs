//! Rules or "filters" that specify actions this program should take on all
//! currently open windows.

#[cfg(feature = "persist_filters_xml")]
mod xml_format {
    //! Serialize or deserialize window filters as XML in the format expected by
    //! the C# program <https://github.com/Lej77/VirtualDesktopManager>.
    //!
    //! The types were initially generated by
    //! <https://github.com/Thomblin/xml_schema_generator>.
    use serde::{Deserialize, Serialize};
    use std::borrow::Cow;

    #[derive(Serialize, Deserialize)]
    pub struct SaveFile {
        #[serde(rename = "@xmlns:xsi", default)]
        pub xmlns_xsi: Cow<'static, str>,
        #[serde(rename = "@xmlns:xsd", default)]
        pub xmlns_xsd: Cow<'static, str>,
        pub filters: Filters,
    }
    impl Default for SaveFile {
        fn default() -> Self {
            Self {
                xmlns_xsi: Cow::Borrowed("http://www.w3.org/2001/XMLSchema-instance"),
                xmlns_xsd: Cow::Borrowed("http://www.w3.org/2001/XMLSchema"),
                filters: Filters::default(),
            }
        }
    }

    #[derive(Default, Serialize, Deserialize)]
    pub struct Filters {
        #[serde(rename = "SaveData", default)]
        pub save_data: Vec<SaveData>,
    }

    #[derive(Serialize, Deserialize)]
    pub struct SaveData {
        pub data: Data,
    }

    fn minus_one() -> i64 {
        -1
    }
    /// Handle xml deserializing for empty elements (these are interpreted as
    /// empty strings by `quick-xml`). This returns `-1` for missing elements.
    ///
    /// See <https://github.com/tafia/quick-xml/issues/497> for more info about
    /// why this is needed.
    fn deserialize_missing<'de, D>(de: D) -> Result<i64, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let text = <&str>::deserialize(de)?;
        if text.is_empty() {
            Ok(-1)
        } else {
            text.parse::<i64>().map_err(serde::de::Error::custom)
        }
    }

    #[derive(Serialize, Deserialize)]
    pub struct Data {
        /// `-1` when disabled, zero-based index
        #[serde(
            rename = "indexLowerBound",
            default = "minus_one",
            deserialize_with = "deserialize_missing"
        )]
        pub index_lower_bound: i64,
        /// `-1` when disabled, zero-based index
        #[serde(
            rename = "indexUpperBound",
            default = "minus_one",
            deserialize_with = "deserialize_missing"
        )]
        pub index_upper_bound: i64,
        /// `-1` when disabled, zero-based index
        #[serde(
            rename = "desktopLowerBound",
            default = "minus_one",
            deserialize_with = "deserialize_missing"
        )]
        pub desktop_lower_bound: i64,
        /// `-1` when disabled, zero-based index
        #[serde(
            rename = "desktopUpperBound",
            default = "minus_one",
            deserialize_with = "deserialize_missing"
        )]
        pub desktop_upper_bound: i64,
        #[serde(default)]
        pub title: Title,
        #[serde(default)]
        pub process: Process,
        #[serde(rename = "isMainProcessWindow")]
        pub is_main_process_window: bool,
        #[serde(rename = "checkIfMainWindow", default)]
        pub check_if_main_window: bool,
        /// Can be omitted in later versions. `-1` when disabled, zero-based index
        #[serde(
            rename = "desktopTarget",
            default = "minus_one",
            deserialize_with = "deserialize_missing"
        )]
        pub desktop_target: i64,
        #[serde(rename = "desktopTargetAdv", default)]
        pub desktop_target_adv: Option<DesktopTargetAdv>,
    }

    #[derive(Default, Serialize, Deserialize)]
    pub struct Title {
        #[serde(default)]
        pub string: Vec<String>,
    }

    #[derive(Default, Serialize, Deserialize)]
    pub struct Process {
        #[serde(default)]
        pub string: Vec<String>,
    }

    #[derive(Serialize, Deserialize)]
    pub struct DesktopTargetAdv {
        #[serde(rename = "allowUnpin", default)]
        pub allow_unpin: bool,
        #[serde(rename = "shouldPin", default)]
        pub should_pin: bool,
        /// `-1` when disabled (not moving to target desktop)
        #[serde(
            rename = "targetDesktopIndex",
            default = "minus_one",
            deserialize_with = "deserialize_missing"
        )]
        pub target_desktop_index: i64,
    }
}

#[cfg(feature = "persist_filters")]
use serde::{Deserialize, Serialize};

use std::{fmt, sync::Arc};

use crate::window_info::{VirtualDesktopInfo, WindowInfo};

#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "persist_filters", derive(Serialize, Deserialize))]
pub struct IntegerRange {
    pub lower_bound: Option<i64>,
    pub upper_bound: Option<i64>,
}
impl IntegerRange {
    pub fn contains(&self, value: i64) -> bool {
        match (self.lower_bound, self.upper_bound) {
            (None, None) => true,
            (None, Some(upper)) => value <= upper,
            (Some(lower), None) => lower <= value,
            (Some(lower), Some(upper)) => lower <= value && value <= upper,
        }
    }
    /// Increment both lower and upper bounds in order to convert from
    /// zero-based to one-based indexes.
    pub fn one_based_indexes(self) -> Self {
        Self {
            lower_bound: self.lower_bound.map(|v| v.saturating_add(1)),
            upper_bound: self.upper_bound.map(|v| v.saturating_add(1)),
        }
    }
}
/// Used to display range in list column.
impl fmt::Display for IntegerRange {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match (self.lower_bound, self.upper_bound) {
            (None, None) => Ok(()),
            (None, Some(upper)) => write!(f, "- {upper}"),
            (Some(lower), None) => write!(f, "{lower} -"),
            (Some(lower), Some(upper)) => write!(f, "{lower} - {upper}"),
        }
    }
}

/// Represents a pattern that can be matched against some text.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "persist_filters", derive(Serialize, Deserialize))]
#[cfg_attr(feature = "persist_filters", serde(transparent))]
pub struct TextPattern {
    pattern: Arc<str>,
}
impl TextPattern {
    pub fn new(pattern: Arc<str>) -> Self {
        Self { pattern }
    }
    /// Check if a text matches a "glob" pattern that allows anything at
    /// newlines.
    pub fn check_newline_glob(&self, mut text: &str) -> bool {
        if &*self.pattern == "\n" || &*self.pattern == "\r\n" {
            // Fast path for pattern that allows any prefix and suffix.
            return true;
        }
        let mut patterns = self.split_newline_glob();
        // First line must be a prefix of the text:
        {
            let first = patterns
                .next()
                .expect("even an empty pattern string should have at least one part");
            if first.is_empty() {
                // The glob pattern allows anything at the start of the text.
            } else if let Some(after) = text.strip_prefix(first) {
                text = after;
            } else {
                return false;
            };
        }
        if let Some(last) = patterns.next_back() {
            if last.is_empty() {
                // the glob pattern allows anything at the end of the text.
            } else if let Some(before) = text.strip_suffix(last) {
                text = before;
            } else {
                return false;
            };
        } else {
            // Only a single line, so after the initial prefix there can't be any more text:
            return text.is_empty();
        }
        // Lines in the middle of the pattern can have anything before or after
        // their pattern text:
        for pattern in patterns {
            if let Some((_, after)) = text.split_once(pattern) {
                text = after;
            } else {
                // The line's text didn't exist in the checked text (at least
                // not after previous line texts):
                return false;
            }
        }
        // Prefix and suffix existed + middle lines existed as well:
        true
    }
    pub fn split_newline_glob(&self) -> impl DoubleEndedIterator<Item = &'_ str> {
        self.pattern
            .split('\n')
            .map(|line| line.trim_end_matches('\r'))
    }
    /// Visualizes a newline delimited glob pattern in a single line.
    pub fn display_escaped_newline_glob(&self) -> impl fmt::Display + '_ {
        struct Helper<'a>(&'a TextPattern);
        impl fmt::Display for Helper<'_> {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                for (ix, part) in self.0.split_newline_glob().enumerate() {
                    if ix != 0 {
                        write!(f, "*")?;
                    }
                    write!(f, "\"{}\"", part.replace('\\', "\\\\").replace('"', "\\\""))?;
                }
                Ok(())
            }
        }
        Helper(self)
    }
    pub fn pattern(&self) -> &Arc<str> {
        &self.pattern
    }
}
impl Default for TextPattern {
    fn default() -> Self {
        Self::new(Arc::from("\n"))
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "persist_filters", derive(Serialize, Deserialize))]
pub struct ExportedWindowFilters {
    pub version: u64,
    pub filters: Vec<WindowFilter>,
}
impl ExportedWindowFilters {
    pub fn migrate_and_get_filters(self) -> Vec<WindowFilter> {
        self.filters
    }
}
impl Default for ExportedWindowFilters {
    fn default() -> Self {
        Self {
            version: 1,
            filters: Vec::new(),
        }
    }
}

/// Specifies how to filter all windows to select a subset and also what action
/// should be applied to the selected windows.
#[derive(Debug, Default, Clone, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "persist_filters", derive(Serialize, Deserialize))]
pub struct WindowFilter {
    /// This index is lower if the window was recently accessed. Limiting this
    /// index is therefore a way to only affect recently used windows.
    ///
    /// Note: uses zero-based indexing.
    pub window_index: IntegerRange,
    /// The index of the virtual desktop that window should be on. If the window
    /// is pinned then that is always allowed.
    ///
    /// Note: uses zero-based indexing.
    pub desktop_index: IntegerRange,
    /// The text in the title bar of a window.
    pub window_title: TextPattern,
    /// The name of the process that created and owns a window.
    pub process_name: TextPattern,
    /// The action to preform on windows that match all the conditions in this
    /// filter.
    pub action: FilterAction,
    /// If the action specifies that the window should move then this specifies
    /// the desktop it should be moved to.
    ///
    /// Note: uses zero-based indexing.
    pub target_desktop: i64,
}
impl WindowFilter {
    #[cfg(feature = "persist_filters_xml")]
    pub fn deserialize_from_xml(xml: &str) -> Result<Vec<Self>, Box<dyn std::error::Error>> {
        let mut deserializer = quick_xml::de::Deserializer::from_str(xml);
        #[cfg(not(feature = "serde_path_to_error"))]
        let data: xml_format::SaveFile = Deserialize::deserialize(&mut deserializer)?;
        #[cfg(feature = "serde_path_to_error")]
        let data: xml_format::SaveFile = serde_path_to_error::deserialize(&mut deserializer)?;

        Ok(data
            .filters
            .save_data
            .into_iter()
            .map(|filter| Self {
                window_index: IntegerRange {
                    lower_bound: Some(filter.data.index_lower_bound).filter(|&v| v >= 0),
                    upper_bound: Some(filter.data.index_upper_bound).filter(|&v| v >= 0),
                },
                desktop_index: IntegerRange {
                    lower_bound: Some(filter.data.desktop_lower_bound).filter(|&v| v >= 0),
                    upper_bound: Some(filter.data.desktop_upper_bound).filter(|&v| v >= 0),
                },
                window_title: if filter.data.title.string.is_empty()
                    || filter.data.title.string == [""]
                {
                    TextPattern::default()
                } else {
                    TextPattern::new(Arc::from(filter.data.title.string.join("\n")))
                },
                process_name: if filter.data.process.string.is_empty() {
                    TextPattern::default()
                } else {
                    TextPattern::new(Arc::from(filter.data.process.string.join("\n")))
                },
                action: if let Some(adv) = &filter.data.desktop_target_adv {
                    if adv.should_pin {
                        FilterAction::Pin
                    } else if adv.target_desktop_index >= 0 {
                        if adv.allow_unpin {
                            FilterAction::UnpinAndMove
                        } else {
                            FilterAction::Move
                        }
                    } else if adv.allow_unpin {
                        FilterAction::Unpin
                    } else {
                        FilterAction::Disabled
                    }
                } else if filter.data.desktop_target >= 0 {
                    FilterAction::Move
                } else {
                    FilterAction::Disabled
                },
                target_desktop: filter
                    .data
                    .desktop_target_adv
                    .as_ref()
                    .map(|adv| adv.target_desktop_index)
                    .unwrap_or_else(|| filter.data.desktop_target)
                    .max(0),
            })
            .collect())
    }
    #[cfg(feature = "persist_filters_xml")]
    pub fn serialize_to_xml(
        filters: &[WindowFilter],
    ) -> Result<String, Box<dyn std::error::Error>> {
        let filters = filters
            .iter()
            .map(|filter| xml_format::SaveData {
                data: xml_format::Data {
                    index_lower_bound: filter.window_index.lower_bound.unwrap_or(-1),
                    index_upper_bound: filter.window_index.upper_bound.unwrap_or(-1),
                    desktop_lower_bound: filter.desktop_index.lower_bound.unwrap_or(-1),
                    desktop_upper_bound: filter.desktop_index.upper_bound.unwrap_or(-1),
                    title: xml_format::Title {
                        string: filter
                            .window_title
                            .pattern()
                            .replace('\r', "")
                            .split('\n')
                            .map(String::from)
                            .collect(),
                    },
                    process: xml_format::Process {
                        string: filter
                            .process_name
                            .pattern()
                            .replace('\r', "")
                            .split('\n')
                            .map(String::from)
                            .collect(),
                    },
                    is_main_process_window: false,
                    check_if_main_window: false,
                    desktop_target: if matches!(
                        filter.action,
                        FilterAction::Move | FilterAction::UnpinAndMove
                    ) {
                        filter.target_desktop
                    } else {
                        -1
                    },
                    desktop_target_adv: Some(xml_format::DesktopTargetAdv {
                        allow_unpin: matches!(
                            filter.action,
                            FilterAction::Unpin | FilterAction::UnpinAndMove
                        ),
                        should_pin: matches!(filter.action, FilterAction::Pin),
                        target_desktop_index: if matches!(
                            filter.action,
                            FilterAction::Move | FilterAction::UnpinAndMove | FilterAction::Pin
                        ) {
                            filter.target_desktop
                        } else {
                            -1
                        },
                    }),
                },
            })
            .collect::<Vec<_>>();
        let xml_data = xml_format::SaveFile {
            filters: xml_format::Filters { save_data: filters },
            ..Default::default()
        };
        quick_xml::se::to_string(&xml_data).map_err(Into::into)
    }
    pub fn find_first_action<'a>(
        filters: &'a [Self],
        window_index: i32,
        window: &WindowInfo,
    ) -> Option<&'a Self> {
        filters
            .iter()
            // ignore disabled filters:
            .filter(|filter| filter.action != FilterAction::Disabled)
            // then find first that can be applied:
            .find(|filter| filter.check_window(window_index, window))
    }
    /// Check if this filter/rule applies to a specific widow.
    ///
    /// The `window_index` should use zero-based indexing.
    pub fn check_window(&self, window_index: i32, window: &WindowInfo) -> bool {
        if !self.window_index.contains(i64::from(window_index)) {
            return false;
        }
        if let VirtualDesktopInfo::AtDesktop { index, .. } = window.virtual_desktop {
            if !self.desktop_index.contains(i64::from(index)) {
                return false;
            }
        }
        if !self.window_title.check_newline_glob(&window.title) {
            return false;
        }
        if !self.process_name.check_newline_glob(&window.process_name) {
            return false;
        }
        true
    }
    /// Display a short string with information about the action and the
    /// targeted desktop. (Displays target desktop with one-based indexing.)
    pub fn display_target_desktop(&self) -> impl fmt::Display {
        struct TargetDesktopFmt {
            action: FilterAction,
            target_desktop: i64,
        }
        impl fmt::Display for TargetDesktopFmt {
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self.action {
                    FilterAction::Move => write!(f, "{}", self.target_desktop),
                    FilterAction::UnpinAndMove => write!(f, "{} (Unpin)", self.target_desktop),
                    FilterAction::Unpin => write!(f, "Unpin"),
                    FilterAction::Pin => write!(f, "Pin"),
                    FilterAction::Nothing => write!(f, "None"),
                    FilterAction::Disabled => write!(f, "Disabled"),
                }
            }
        }
        TargetDesktopFmt {
            action: self.action,
            target_desktop: self.target_desktop.saturating_add(1),
        }
    }
}

/// Specifies what action to preform on a window that a [`WindowFilter`] has
/// selected.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default)]
#[cfg_attr(feature = "persist_filters", derive(Serialize, Deserialize))]
pub enum FilterAction {
    /// Move the window to another virtual desktop. Do nothing if the window is
    /// pinned and therefore visible on all desktops.
    Move,
    /// Move the window to another virtual desktop and if the window was pinned
    /// then unpin it first.
    UnpinAndMove,
    /// Unpin the window so that it is no longer visible on all desktops.
    Unpin,
    /// Pin the window so that it becomes visible on all desktops.
    Pin,
    /// Do nothing with the window. This can be useful to prevent some windows
    /// from being affected by any other filter.
    Nothing,
    /// Disable this filter. The program will act as if this filter didn't exist.
    #[default]
    Disabled,
}
impl FilterAction {
    pub fn as_str(&self) -> &'static str {
        match self {
            FilterAction::Move => "Move",
            FilterAction::UnpinAndMove => "Unpin and move",
            FilterAction::Unpin => "Unpin",
            FilterAction::Pin => "Pin",
            FilterAction::Nothing => "Nothing",
            FilterAction::Disabled => "Disabled",
        }
    }
}
/// Used to represent the action inside the configuration window.
impl fmt::Display for FilterAction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(self.as_str())
    }
}
